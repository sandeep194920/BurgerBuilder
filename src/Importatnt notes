** This is some notes I've made while coding along. 

Set 1 Workflow as follows:

1. Initial videos show how to setup the structure. Initially, everything will be div and we replace one by one with component
2. In video 159, he shows how to convert JS object to array. I've modified a little bit but the concept is same.
  * Doubt I have in this concept of conversion : He uses [...Array(some length)].map(........)
  * Here I see [...Array(lenght)] creates [-,-,-] empty spaces and maps though this, fills the spaces with content and 
    then returns it. But I tried doing - new Array(length).map() and it didn't work. But I see even this creates 
    empty spaces like this [-,-,-].  I will answer this below if I find it.
Commit (0cf0fa5) - added functionality to convert object to array in burger to pass it tâ€¦
3. In video 160, in the process of flattening the array, I used .flat() but he used reduce function. Both are right, but learn this, it might be useful.
4. To know a bit about css flexbox - https://www.youtube.com/watch?v=JJSoEo8JSnc
   Flex box is best way to design grid css. 
5. Now we are building BuildControls (which includes BuildControl) component.

To summarize workflow till here: 

Set 1 Workflow summary:

* Project structure created with create-react-app
* Added font (open-sans)
* Created components and containers folders
* Layout was created and App component holds Layout
* Inside Layout we now should have 
  a. Toolbar, SideDrawer, Backdrop, Logo and NavigationItems
  b. BurgerBuilder
     b.1 BurgerBuilder should have Burger
          -> Burger will have BurgerIngredients
            -> BurgerIngredients will have individual BurgerIngredient
     b.2 BuildControls
          -> BuildControls will have individual BuildControl

Note : So far we have done till BuildControls (UI Of BuildControls). v0.1 tag in git starts from BuildControls
Next we will hookup BuildControls to state (video 163 - Connecting State to BuildControls)

* * * Tag v0.1 - Building the Burger

Set 2 Workflow as follows:

6. Added (My way to connect the state to BuildControls), and also disabled 'Less' btn if the ingredients are 0
7. Commented the functionalities : addIngredient, removeIngredient in each component which I had created (comments say - My way of ... )
8. Built the same functionalities in Max's way. I did this just to compare my way to his and make my building process better
  Note : I added a method countIngredients() in BurgerBuilder component to help remove ingredients. But when I saw Max's 
  explanation, I didn't feel the need to add this. So you can see the uncommented way of doing the same in removeIngredientHandler()
  Also, I felt disabled ingredient button functionality - My way is better than Max's way.

9. Added price functionality and also dispalyed in UI. It's pretty straight forward.
10. Now adding Order Now button in BuildControls component.
  * For this, it will also be good to disable this button if no ingredients are added. 
    Hence we make use of 'purchasable' property in BurgerBuilder state. If it's true then it is purchasable, else no.
  * Adding a method 'updatePurchaseState' which at the end is called in addIngredientHandler and removeIngredientHandler
    to check if the above added 'purchasable' property need to be updated after ingredient being added or removed
  * You can see the error (video 166. Adding order button), where the state of the ingredients is not up to date. 
    We got to know this when we needed to add two ingredients for the ORDER NOW button to become enabled. 
    Hence we passed the parameter of updated ingredients into updatePurchaseState(). 
  * Now, I wrote the Max's way of getting totalIngredients inside updatePurchaseState(). Refer that method for detail 
    explanation about map and reduce shown with and without return statement

11. Modal, Backdrop creation phase
  * Modal is a wrapper (container), shown in middle of the page. Inside this, we can show any component (props.children) as per our needs
  * Backdrop is used with Modal so that when the Backdrop is clicked, the modal disappears
  * Backdrop is not put inside Modal folder itself because, the backdrop can also be combined with sidedrawer (designed later)
  * WHERE TO ADD ? --> So, first develop the modal and then think which container/ component is the suitable place to add this modal,
    in our app it is BurgerBuilder container since it has state and other things there
  
12. Created OrderSummary
13. Dynamically showing OrderSummary Modal now. 
14. Created a Backdrop and added it to the Modal. We can add Backdrop anywhere like App or Layout, but then we
    need to make sure that we handle that properly by managing state etc..
    * But it makes more sense to place Backdrop inside Modal (For sidedrawer, its also suits to place backdrop in sidedrawer).
      This is because Modal is closely connected with Backdrop. When Modal opens or closes, then Backdrop also needs to open/close.
    * We also implement onClick in Backdrop because, as I said, if Modal closes then Backdrop should also close. Clicking BD should close both modal and BD.

15. Two buttons are now required to be present in OrderSummary. So it's better to create its own component. Hence created
    Button in UI folder. 

16. Now that we built the Button, and used two buttons (Continue and Cancel) in the OrderSummary, we now need to implement the onClick for them.
    Cancel Button is same as clicking backdrop so we can use purchaseCancelHandler (as backdrop) for that. We need to 
    implement Continue button click, and this will be purchaseContinueHandler. 
    * First we just give alert message in purchaseContinueHandler just so we know it's working. Later we will tweak it.

17. Adding the price in the OrderSummary before we move to build Toolbar


* * * Tag v0.2 - completed - build the burger, continue checkout or cancel. Now proceeding with the toolbar in the next version. Note: Continue button just shows alert for now. It's yet to be implemented

Set 3 Workflow as follows:

18. Design of Toolbar - We are going to add this component in Layout component. Toolbar resides in Navigation Folder.
    Other components like NavigationItems will also reside in Navigation component. (Refer point number 5 bullet points about Toolbar)
    * Note: BEST PRACTICE : The toolbar component should contain <header></header> with in which the other components like button(for sidedrawer),
          Logo, and navigation items should be. Navigation items inside the toolbar should be in <nav></nav>
    * Note: z-index for toolbar is 90, backdrop 100, sidedrawer is 200 and modal 500. First Modal, next backdrop, next sidedrawer and then toolbar. 
      We will see sidedrawer later.

19. Logo - Added from Max's resource file. In Logo.module.css, we set box-sizing:border-box. The meaning of this is - we
           need the height of the .Logo to be 80%, and we also need padding to be the part of this. That is the meaning of
           box-sizing:border-box
           
20. Now we need to do the navigation items which go into the <nav></nav> in the toolbar. We need to outsource this because 
    we will be using it again in the sidedrawer. NavigationItems component is created for this and then NavigationItem is created.

21. Now that we added Navigation to toolbar (desktop), it's time to add Navigation to mobile devices and that is by sidedrawer component. Now 
    we added SidDrawer but the logo looks big. So logo and navigation items need to be taken care of, so we next include
    responsive css to NavigationItem.

    Note: So the problem at this point is that, the logo is bigger in sidedrawer. The reason is, in the Logo css, we 
    set height of logo to 80% to look good in the toolbar. But the same logo component when used in the sidedrawer looks
    way to bigger due to its 80% height. 
    So the 80% height is ok for toolbar and not to the sidedrawer. The thing to observe here is that we are kind of 
    favouring toolbar and not the sidedrawer in the logo css. So two things we can do here: 

    1. Make the logo responsive. For bigger screen, it should be 80% (sits on the toolbar) and smaller height for sidedrawer.
    2. Set the logo height back to 100% and then change its height in toolbar css and sidedrawer css. So, that means,
       we are actually setting the height of the logo when in toolbar or sidedrawer when those components are used accordingly.
  
   Here we are following second approach which I think makes more sennse as the logo can then be generic in logo css.
   In conclusion, we reset logo height both in sidedrawer as well as toolbar accordingly. REFER Video 177. Working on Responsive Adjustments to understand this

22. Now taking care of navigation items to look good on mobile devices (responsive css for NavigationItems). We are making 
    this in Mobile first way.

23. Now adding Backdrop to the SidDrawer component. We need an onClick listener of backdrop come back to sidedrawer which 
    inturn should come back to Layout. We can handle this click in SidDrawer itself which comes from backdrop, but 
    Layout would be the appropriate component to handle this click listener because we need a connection between 
    the toolbar and sidedrawer at the end. That is because when the menu button in the toolbar is clicked, then only
    the sidedrawer should open. So, the component which holds toolbar and sidedrawer is the layout. So we add 
    SidDrawer component's Backdrop's click listener in Layout.

    In this commit we also added hamburger icon component (DrawerToggle) and placed this in SidDrawer component. This is 
    the replacement of MENU text in the toolbar. The reason for placing this in the sidedrawer component is that it 
    actually belongs to the sidedrawer even though it resides on toolbar, because this button is mainly used for 
    showing or hiding sidedrawer.

24. Added Max's css for DrawerToggle
25. Performance Optimizations : One thing at this point if you notice; the modal simply is rendered everytime
    even though we don't click Order Now btn. The reason for this is, the render method of BurgerBuilder is run everytime
    if something on the BurgerBuilder changes, for example, if I add a component, the BurgerIngredient is added and hence 
    the Burger part changes and hence the BurgerBuilder changes. When the BurgerBuilder is changed the BurgerBuilder's
    render is run again. When this happens, the Modal (also OrderSummary inside Modal) is run everytime.

    So, to summarize, when BurgerIngredient is added/removed the Modal is rendered because it resides in render of BurgerBuilder
    which changes when this happens. This is a performance hit. To avoid this we use shouldComponentUpdate. This shouldComponentUpdate
    can be used in two places - Modal or OrderSummary. But the right place is Modal because it is the one which wraps 
    OrderSummary. So I would convert Modal into class based (can be done with react hooks later) and implement shouldComponentUpdate.

   * What is PureComponent (class based) or React Memo (react hooks based)? 
   
   PureComponent/React Memo is shouldComponentUpdate functionality but it compares all the previous props with the present props.
   It's needed sometimes but not all the times. Here in the Modal we could have used it but its an overkill because we have
   only one prop that is show prop which needs to be compared, and this alone would be enough to tell if the Modal needs
   to be rendered or not. Hence using PureComponent here in Modal is not necessary.

26. Modifying the folder structure a bit: When we started the project, the Layout was a stateless component but now 
    it handles state. So for a moment we feel its better to move this folder into Containers. But if we take a closer 
    look at Layout, all it does is just Wraps the props.children (BurgerBuilder for now and other components like Authentication Page later),
    and it also has fixed Toolbar and SidDrawer. So, the main focus is that it wraps the children and hence we can consider
    this to be a higher order component. Moving Layout into hoc folder makes more sense, but its not mandatory. 
    I am moving it into hoc here.

    We are DONE WITH THE CRUCIAL BASE PART OF BURGER BUILDER



* * * Tag v1.0-release - completed - COMPLETED BASE PART. BURGERBUILDER, TOOLBAR, SIDDRAWER, MODAL, ORDERSUMMARY all done. 

Set 4 Workflow as follows:

 Implementing Backend - Firebase - When we click Order Now button, the Orders should go and store in firebase

27. Watch video for steps to create project on firebase console. No point in noting them here. (Video 209 - Creating the Firebase project)
    Once you setup the database, in the rules part, set read and write to true. This can be changed once authentication is implemented.

    DB URL : https://react-my-burger-664c0.firebaseio.com/

28. Now that we have setup the Database, we'll send http request now using library called axios.
    npm install --save axios. We can use axios two ways. One is globally and other way is using axios instance.
    Here we use axios instance. So I'll create axios-orders.js file in src folder and create axios instance for orders here.

   Creating axios instance : 

    * First we create instance of axios using axios.create() and assign baseURL inside. 
    * Assign this function to a variable and export that as default.
  
  Later in the course, we use a different URL for authentication hence we now created an instance.

29. Now we have set the axios instance, we now should be able to send the POST request. Where to send POST request? 
    Well, the right place to send POST request (for sending orders to Backend) is purchaseContinueHandler() in BurgerBuilder.
    Here we are just alerting now if we click Continue button.
    Note: We later change this by adding some more functionalities. We later will fill a form before we send order to Backend.
    But for now in the purchaseContinueHandler(), we send the order to backend using POST request of axios. The url written
    in the post() is the url written in the post + baseURL written in the instance of axios.

    example :instance --> baseURL('xyz.io'),  post('/orders.json'), mainURL -> 'xyz.io/orders' (For firebase, adding .json is important)
    The requests and responses are asynchronous. Meaning, it doesn't expect for the program to stop while it requests data from server.
    Instead the program continues and if we then try using this response in the normal flow, we might get an error 
    as the response data might not be ready yet. Hence we use promises in then block of POST and GET of axios.
    then block code is a different thread altogether and once its ready then that data is updated in the program wherever 
    necessary.

30. When request is being sent and recieved it might take some time to get the data back. We usually show spinner or 
    something on the screen so that user know that it's loading. This spinner can be shown in place of OrderSummary.
    Spinner is shown inside the modal in place of OrderSummary and the modal then disappers once the order is placed 
    (we get the response back).
    Creating Spinner inside UI as it is an UI component.
    Getting spinner from https://projects.lukehaas.me/css-loaders/
    BG color FFFFF and FG Color 521751 selected for spinner

    VERY IMP NOTE : I fell into this trap. While setting the spinner inside the modal, my spinner was working but the
    OrderSummary wasn't showing after continue button click. Reason is in the modal, we are not checking if the props.children
    changed (i.e., Spinner & OrderSummary). So basically, in shouldComponentUpdate in the modal, we also need to check
    this with the exisiting check for show prop

31. Adding Error handler hoc - If something went wrong in a component like BurgerBuilder (or any other component) and we need to 
    display the error message (inside the modal on that component), then we can use a higher order component which 
    returns a function which when executed executes the passed component with additional modal that exists. Sounds Confusing right?
    Watch video 213. Handling Errors
    We use withErrorHandler
    Note : This type of hoc can be implemented on any component for any purpose, not only errors.

32. In the previous task we posted orders into backend. Now let's get ingredients from backend using get method of axios.
    We will get rid of ingredients present in the BurgerBuilder state and get that from firebase.

    IMPORTANT NOTE : In this commit there are multiple changes to be noted. 

    1. We changed if loop in the BurgerBuilder component. This is used because we render ingredients from backend and the
       components using this will fail if it's not loaded on time. Hence we show spinner dynamically for which we added if loop.
       Components included under this if for dynamic rendering are the ones which depends on ingredients(passing props to its children).
    2. The ComponentDidMount in withErrorHandler is converted into ComponentWillMount after this ingredient has been put to firebase.
       The reason for this is, if we make a typo in ingredient rendering url, in axios.get('/ingredient.json'), we don't get 
       the error displayed on the screen like what we get for post ('/orders.json').
       This is because, the ingredients is fetched inside <BurgerBuilder/> which is a child of withErrorHandler and the CDM inside withErrorHandler
       is executed after the child. In this case the cdm is never called. The error actually occurs in child part first in which case
       the cdm in withErrorHandler never executed. So cdm is converted in to cwm. In future cwm will not be supported hence we 
       can use constructor in withErrorHandler which I am not doing it here.

33. ComponentWillUnmount : This is used to unmount the component and clear anything like interceptors. For better understanding, watch
    Video 215. Removing Old interceptors. Unmounting actually means disappear from dom. So ComponentWillUnmount will be 
    executed when the component is disappeared from dom. At this time we need to clear (eject) any old interceptors, so that when we use
    withErrorHandler(AnyComponent) we don't end up creating more and more unused interceptors.

* * * Tag v1.1-release - completed - Completed Axios part. Now moving on to routing with react-router

Set 5 Workflow as follows:

 Implementing Routing - Single page application - Feels like multi page using react-router
 
34. Now time to implement the second page. The page we built till now was BurgerBuilder, and the fixed toolbar and sidnavs (common for all pages),
    but now we will build checkout page. To give a bigpicture, we first started with BurgerBuilder component and now
    when we click checkout link on the toolbar, the BurgerBuilder should disappear and Checkout page should appear.
    For this we implement routing to handle multiple pages. We create Checkout container (Folder, js and css) in same 
    level as BurgerBuilder inside containers folder.

    In the Checkout container we have info about what user will buy like burger itself, continue and cancel buttons. 
    The goal is to take the user to the form later once he hits continue. To achieve this Checkout component we create
    Order inside components which holds CheckoutSummary.

    NOTE : We built Checkout component which needs ingredients from BurgerBuilder as props to pass it to its child component.
           But the Checkout and BurgerBuilder are of same level. I mean like below diagram

                    -- BurgerBuilder --> This has ingredients
                    |
           Layout --
                    |
                    __ Checkout  --> This needs ingredients to pass it to CheckoutSummary
          
          How to get ingredients into Checkout now?
          We will answer this later. Reference to this problem is lets say 111 (This is just for reference which I can use when I answer this below)

35. npm install --save react-router-dom  
    Installed rreact-router-dom and react-router package. Above npm installs both of these.

    Component Wrapped with BrowserRouter - The main component or the component used for Routing (This automatically includes children) should be 
    wrapped with BrowserRouter so that where ever the Route is used it works.
    Switch is used to match the single Route. When that Route is hit then it stops checking other Route elements.

36. Need to show Checkout component on clicking continue button. Checkout component should be replace BurgerBuilder on continue btn click
    We comment the code responsible for sending order to backend on-click in purchaseContinueHandler because this part 
    should be done later once we checkout finally after filling checkout form (which will be added later).
    Instead of sending code to backend, when we click continue we need to replace BurgerBuilder page by Checkout Page 
    using Routing as I described above. Hence commenting the code responsible for sending order to backend in purchaseContinueHandler.
    
    NOTE : <Route path="/" component = {ABC} />   --> Suppose XYZ component is the child of ABC
    
    Here, not that when we check the props inside XYZ (which is in Route here) we see history, match and so on.
    But eve though XYZ is the child of ABC, XYZ will not have all these props like history, match and so on.
    There are two ways to get these props in XYZ (child of ABC) incase we need it.

      * By passing on props to children
      * By using withRouter HOC on XYZ. We take this approach as its the most elegant way of doing it.

37. Now we have checkout page that appears on continue button click. We now need to implement button clicks for cancel and 
    continue which is on the checkout page (CheckoutSummary component). If clicked on cancel of checkout we need to 
    go back to the BurgerBuilder component again, and on clicking the continue on the checkout page should take us to the 
    contact-data form which we will implement later.

38. Now that we implemeted Cancel checkout functionality, we need to take care of Continue checkout. Before we do that 
    it's now time to solve the problem we had above about the Burger that appears in Checkout. In point number 34. I had
    written a note which I'll represent again below. 

    NOTE : We built Checkout component which needs ingredients from BurgerBuilder as props to pass it to its child component.
           But the Checkout and BurgerBuilder are of same level. I mean like below diagram

                    -- BurgerBuilder --> This has ingredients
                    |
           Layout --
                    |
                    __ Checkout  --> This needs ingredients to pass it to CheckoutSummary
          
          * How to get ingredients into Checkout now?

          ->  We solve this here by using queryparams. Now you can see the difference between passing the props and 
          the query params. 

          -> Passing props works through series of components if there is a parent child relationship. I mean if the 
             passer is the parent and the reciever is the child.

          -> Passing props doesn't work if there is no parent child relationship and if components are at parallel levels like
             BurgerBuilder and Checkout. In this case we can use queryparams.

39. Now that we generated the queryParams where we get the URL http://localhost:3000/checkout?ingredients=bacon=0&cheese=0&meat=0&salad=1
    when we click on continue orderSummary, we now need to take care of using this queryParams in the Checkout to create 
    the ingredients. We do this in ComponentDidMount inside Checkout because when the continue button on the orderSummary is 
    clicked we show/mount the Checkout component on to the DOM. Hence ComponentDidMount is the ideal place to use this queryParams.
    These queryParams which is passed in purchaseContinueHandler in BurgerBuilder to the Checkout component will be available in location props.
    (Do a console log of props in the purchaseContinueHandler and you will know. The same props will be passed so you can access 
    in Checkout component)
    To extact this query params which is in search prop, we use URLSearchParams(this.props.location.search) inside CDM 
    of Checkout

40. We now get the ingredients from BurgerBuilder into Checkout component thorugh queryParams. Let's now build ContactData.
    We will build it as a container since it manages its own state. This will be under Checkout folder.
    We show this ContactData as nested route i.e inside Checkout itself.
    
    QUESTION I HAVE : But One thing I don't understand is Why we need nested route when we can just use that component normally inside 
    checkout?
    The answer is that if I use ContactData normally then it will be loaded right away when Checkout is loaded. But we 
    want the behavior such that the ContactData should be loaded when the Checkout continue button is clicked.

41. We have built basic version of ContactData. Let's now submit the order by clicking ORDER button in the ContactData.
    We will tweak ContactData later when we use forms.
    When we click button inside the form, it reloads the page. To avoid this default behavior we use event.preventDefault()
    inside the orderHandler() in ContactData.
    Also, we need to pass ingredients and totalPrice from Checkout to ContactData within the Route as props. For this we can convert 

    <Route path={this.props.match+"/contact-data"} component={ContactData}/>
    into 
    <Route path={this.props.match+"/contact-data"} render = {()=>(<ContactData ingredients={ingredients}) price={this.state.totalPrice}/>}/>
                                                      |
                                                      ^
                                                      This render takes arrow function as input. Refer Routing videos for this explanation.
                                                    
    By converting the <Route path= .. above, we are now able to pass the ingredients and totalPrice to ContactData, but the drawback is 
    we will not be able to pass history, match and other Route related props (These props are required because we need to use history props in orderHandler
    inside ContactData to redirect to homepage after order has been placed).

    To get the Route props like history and match we can use two approaches.
        1. To wrap the ContactData with withRouter (import {withRouter} from 'react-router-dom') because this is the component in which we like to get the Route props.                                           
        2. To pass on the props like how I do in Checkout component. I use 

        <Route
          path={this.props.match.path + "/contact-data"}
          render={(props) => (----------------------------------> props passed here is the props of react-router-dom that includes history, match and so on..
          <ContactData
              ingredients={this.state.ingredients}
              price={this.state.totalPrice}
              {...props}/>---------------------------------------> props here is the props coming from react-router-dom (histoy, map and so on). I also tried ...this.props here and that is the Checkout component props and not react-router-dom's props

     I took this approach as Max but I also tried removing props in the render = {(removed here)} and for {...props} I did {...this.props} and 
     that works too. Here I can simply pass the props which is used in Checkout and that includes Route props.

    Again, all these are done here just to be able to use history props to redirect to homepage after ordering in ContactData

TODO : At this point (Video 257. Order Submission & passing data between pages) everything is working fine but there is one warning which I'm not able 
       to figure out at this time. 

       When I click Order button (of ContactData), I get this warning below

    Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
    in ContactData (created by Context.Consumer)
    in withRouter(ContactData) (at Checkout.js:64)
    in Route (at Checkout.js:61)
    in div (at Checkout.js:50)
    in Checkout (created by Context.Consumer)

    I tried reading through all the comments in QA section but no luck. I guess it has something to do with ComponentWillMount and componentWillUnmount.
    I will come back to this once I have an answer for this.

42. Now the goal is to create My Orders page. We create Orders folder inside the containers because like BurgerBuilder and 
    Checkout, even Orders should be a separate page so it should come under same level of BurgerBuilder and Checkout.
    In this Orders, we need to return list of individual Order Components. Hence we create Order and its Css in 
    the Order folder which already exists in components.

43. Now that we have created My Orders page ( not yet getting the Orders from backend in there), we now update the Checkout Link to
    Orders link. We replace anchor tag (<a />) in the NavigationItem with NavLink tag. NavLink is also known as Link tag having 
    additional functionality of inbuilt active css class which we can use to lighlight the link. So if you use Link and apply 
    css of active manually then that also would have same effect of using NavLink. 
    The reason we replace <a/> tag is, when we click on a tag, then the page reloads but we don't need that behavior since
    we lose all the data of state if page reloads. Hence we use Link or NavLink.
    Take a look at the comments written in NavigationItem to get some clarity.
    This acive class concept is bit tricky. Go through video 259. Implementing NavLinks, to get more on this.

44. Now in the orders page, lets now get the orders from backend. We get orders from firebase in object format, we convert
    that to array so that we can use map on that. In this process, we use the key prop (we assign this unique key from orders backend), so that
    we can use this as key in map function. All this is done in Orders.js. Also, to display errors if any, we use
    withErrorHandler hoc in Orders.js. The hint when to use withErrorHandler is - use it when we use axios and when
    we think error occurance is possible. 
    In this commit we wrote all the logic to get the orders from backend and wrapped the orders component with withErrorHandler.
    In the next commit we will work on displaying the fetched orders properly using order component.

45. Let's modify Order.js component to display all the ingredients and price things which we get as props from Orders.js.
    Displaying Orders is done. Now need to work on checkout form next. 

* * * Tag v1.2-release - completed - Completed Orders part, so we have BurgerBuilder and Orders done with only Checkout form design left. 
                                    Now moving on to designing checkout form

Set 5 Workflow as follows:

 Designing checkout form - We'll design checkout form (ContactData.js) and its validation here. The design process includes
 * Currently the state in the ContactData is not used. Firstly, we need to decide which all data is used in ContactData
   that we like to store in backend (now its hardcoded in orderHandler in customer object), and then need to sync that with the state.
 * Dynamically use components of form
 * Cater for form validation. Note that the formik library works for form validation and form Submission which we are not using it here.

46. We start the form with first putting input in their own component (UI/Input) and using that in ContactData. Note that 
    this part of ContactData can also be done using formik (forms library) for future projects.

47. Now that we have designed inputElement (input, text area and so on - for now we have only input), we will now focus on 
    inputElement in detail. I mean what should go into each inputElement.
    Time to think about what customer info like name,email etc. has to be passed into Orders backend.
    Let's talk about inputElement 'input'. We will now think what data needs to go into this. Like name, email etc.
    So, we can then write the state in the ContactData accordingly. Now we modify state of ContactData.

48. Now we convert orderForm in the state of ContactData into an array so that we can loop through each elementType and 
    output jsx for each of the <Input/> elementType. To convert object into an array this is one of the examples you can 
    refer later if you want (Video 268. Dynamically create Inputs based on JS config)

    Process we used to convert orderForm state Object to array in ContactData.

    * We have 
    orderForm: {
         name: {
            elementType: "input",
            elementConfig: {
            placeholder: "Your Name",
            type: "text"
            },
            value: ""
         },
        street: {
            elementType: "input",
            elementConfig: {
            placeholder: "Your Street",
            type: "text"
            },
            value: ""
        },
      AND SO ON ....
        
    }

    At the end we need something like this :
    <Input elementType = 'name' value = '' placeholder = ' Your Name' type = 'text'/>
    The type and placeholder would be common for many inputs so we have put them in elementConfig

    We could hardcode the Inputs, <Input/>, statically, but to render this dynamically we need to convert the above object of 
    orderForm into an array like this

    [  
        id : name,
        config : {
            elementType: "input",
            elementConfig: {
            placeholder: "Your Name",
            type: "text"
            },
            value: ""
         }
         ,
         id : street,
         config : {
            elementType: "input",
            elementConfig: {
            placeholder: "Your Street",
            type: "text"
            },
            value: ""
         }
    ]
    So basically, I need id and the name of the attribute as keys. The values would be the one inside them.

    * To convert obj into array

    formElementsArray = []
    for (let key in orderForm){
        formElementsArray.push({
            id:key,
            config : orderForm[key]
        })
    }

    Now we have the above filled array. This can now be looped into jsx for <Input/>

49. Let's take care of dropdown for deliverymethod in orderForm.

50. Now that we have done adding all the fields in the form dynamically, lets handle the inputs onChange. 
    This helps for form validation as well. 

51. Now that we have set two way binding, we now handle form submission. We already have the orderHandler functionality
    for form submission like this 

    <form>
        ...
        <Button btnType="Success" clicked={this.orderHandler}>
          ORDER
        </Button>
    </form>

    We remove this clicked here and put this inside form tag for submission like this using onSubmit

    <form onSubmit={this.orderHandler}>
        ...
        <Button btnType="Success" >
          ORDER
        </Button>
    </form>

    Also, currently we have ingredients and price being passed to backend when we order. We now need data from the 
    orderForm.

52. We are now getting formData (user data) data in the backend. However, at this point, we have a bug. On selecting 
    option 'Fastest', we are not getting any data for this field in firebase. We fix this later.
    
53. Now we need to handle form validation. 

    Steps followed here for adding validation:

     * The idea is to have a check (validation) on every inputElement. The rule can be anything like - required, 
       only numbers to be entered, min-length, max-lenght and so on.
    *  Now let's think where to have the validation check. The best answer is - 
       The moment I touch the (click the) inputElement field, the validation rule (any or every above mentioned)
       should activate on that particular element. 
    *  Though this can be done in many places in many different ways, let's take a look at ContactData's inputChangedHandler().
    *  This is the method which is activated or called (onChange) when the user types something into the inputElement field. 
    *  So, think this way - "The moment the user touches the inputElement and types something, the value is registered in state
       and during this time its a good idea to also check if the user is typing as per our defined rules. If the user
       doesnt type as we want then we can throw the message here. So, again, the place to add is - soon where we capture the value 
       onChange".
    *  So, the best place would be in inputChangedHandler() after the line - 'updatedFormElement.value = event.target.value;'
    *  In the above line, we get the value entered in the box and after this line (in the next line), we can validate 
       if the user entered the value as per the rules we defined like below:

        1-------updatedFormElement.value = event.target.value; // after this line, below is the validation check
        2-------updatedFormElement.valid = this.checkValidity(updatedFormElement.value,updatedFormElement.validation); // I will explain this in a moment

    *  So, 1 says the value entered in to the inputElement and 2 validates if it is proper and returns true (if rule is met) or false (if rule not met).
    *  Now the question is, all sounds good but where is the rule defined ? What is the second parameter passed into 2 this.checkValidity() ?
    * Let's answer one by one. 
    *  where is the rule defined ?
       - The validation rule / rules can be defined in the state in each inputElement like name, state, email and so on. See ContactData. There 
         you can find the validation object which are the rules.
    *  What is the second parameter passed into 2 this.checkValidity() ?
        _ This validation object from the state (deep copied object) is passed as the validation rules to check each rule is statisfied
          in the checkValidity method. If each rule is statisfied then it returns true, and this true or false can be 
          represented in css later for showing errors or warnings.
    
    These are the steps followed to add validation to any form. Later we will learn formik library which makes our forms 
    and its validation easier. We don't learn in this project though :) 

54. Now that we have added validation rules, we need to use this to give feedback to the user if the value entered in inputElement doesn't 
    match the rule. So we are going to add a new Css class for this in the Input component to give a red colored look 
    for the inputElement which is not validated. We have completed this part but now there is a problem. The problem is that, now
    we have all fields red colored right from the time we see the form which is not a good user experience. Instead, we 
    want the user to see red colored (as a sign of not validated - meaning not inputted as per rule) only when the user 
    clicks on that particular inputElement atleast once.  We will do this next.

55. When we touch the inputElement atleast once we need to apply red color css (apply validation rules).

56. Now that we have tested individual inputElement for validation, now we need to check if the overall form is valid, and if yes, then we should 
    be able to continue. This we do it by checking individual elements in the for in loop for validity inside inputChangedHandler(). 
    Once everything is validated to true then the overall form will be valid and hence we can continue to order (click order btn).
    Though we did everything required in the validation part, we have one glitch here. That is the deliverymethod. If you 
    don't change the deliverymethod and leave it in Fastest (default) you wont get an error but when it is changed to 
    Cheapest, we get the error. 
    This is because the validation (validation rules) on the deliverymethod is not defined 
    which is not required, but this creates a problem during checkValidity(value,rules) call where the rules are basically the
    validation object which is not present in the deliverymethod (which is not required as I said) and hence, this when 
    changed to Cheapest, the rules is set to undefined and hence we get the error.
    Let's solve this in next commit.

57. The fix is simple. Let's understand why we get the error for deliverymethod drop-down. The rules (validation) is not 
    defined. In this case it will faile at line - if(rules.required) becuse there is not rules at all (validation) in the 
    deliverymethod inputElement to check for the required property. Hence we simply add an if at the beginning in the 
    checkValidity(value,rules) like so,

        if(!rules){
            return true;
        }
    That solves the problem of deliverymethod drop-down validation. However, there is a small bug though and we will fix 
    this in next commit.

58. We forgot to enter the default value for deliverymethod and I entered in this commit as fastest. This helps in registering the
    value of deliverymethod as fastest in the backend if we dont touch the dropdown.

 FYI : There is another bug which I came across, which I am not going to solve here, and also not addressed in the Max's lectures. 
       The bug is, in the ContactData form validation (overall form validation), everything seems to work fine when the data
       is entered manually into each inputElement and once all the inputElements are done, the ORDER button turns green from 
       gray indicating formIsValid is true now, meaning overall form is valid (each element validated successfully and now ready to proceed).
       However, when entering a data in the name field, it gives some suggestions to fill all the fields (all inputElements) 
       with some cached data of form. When I click the prepopulated data, all the fields are filled but the ORDER btn doesnt immediately turn 
       green. 
       The reason (my assumption) is, I have used {valid:false} and the logic to turn this true for each inputElement, where it says each element 
       when touched turns up the valid property to true and the overall form will be valid if and only if the individual elements are valid:true. 
       In case of autopopulated data, though all the fields will be filled, the fields individually won't be touched by user and that can still 
       keep the individual inputElement valid : false. This is the reason why sometimes the overall form, formIsValid, is false and the ORDER btn doesnt 
       turn green. 
       I guess this problem doesnt occur if we use formik library, but not sure since I havent used it yet.

* * * Tag v2-release - completed - DONE WITH CHECKOUT FORM. NEED TO MOVE TO REDUX NOW.

Set 6 Workflow as follows:

* Adding basic and advanced REDUX
 
  Note: All the basics and advanced REDUX concepts have been explained in https://github.com/sandeep194920/react-counter-with-redux
  
  59. First, we need to look at which all components have state (containers) and which parts of those states need to be 
      put into redux store. Let's see some of the containers and its state and decide which could be a better candidate 
      to go into the redux store.

      * BurgerBuilder state

        state = {
            ingredients: null, 
            totalPrice: 4, 
            purchasable: false,
            purchasing: false,
            loading: false,
            error: false 
        };

        ** We have these attributes in state. Only ingredients and totalPrice would be carried from one component to 
           another but the other attributes like purchasable, purchasing etc are used for UI change purpose. For example,
           loading:false is used because at some point we need to turn loading to true or false to change the UI. Hence this 
           type of attributes doesn't required to be put into store.

      * Checkout state 

        state = {
            ingredients: {},
            totalPrice: 0
        };

        ** This we discussed for BurgerBuilder state above. We can already see the usecase of using ingredients and totalPrice
           from store so we don't need query params to pass them as arguments. 
    
      * Orders.js state has orders =[] where the orders are coming from backend. We do this part later in advanced redux part
        as this is async part of redux. orders need to be fetched asynchronously from firebase. 
  
  60. Installing redux and react-redux. 
      npm install --save redux react-redux
      Let's start by creating store folder in src and adding actions.js and reducer.js as learnt in the redux-counter project.
      
      * Where to start from?
      ** Let's start with BurgerBuilder. As I told, we will be dealing with ingredients and totalPrice. First ingredients.
         So we can see we have handlers addIngredientHandler and removeIngredientHandler related to the ingredients. These are good fit to go into the 
         actions. Remember, the handlers could be most likely the actions, because in the handlers we change somethings in 
         state and that is what we generally do in actions to update the store. After this, we can update the store accordingly.
  
  61. Connecting react with redux. 
  62. Now that we have created store in index.js, let's implement two actions ADD_INGREDIENT and REMOVE_INGREDIENT in the reducer.
      Note : In the BurgerBuilder state, we have ingredients as null because we get the components from firebase in ComponentDidMount.
      We will add this functionality of getting from backend into redux store later (async action - advanced redux) but for now we 
      will hardcode ingredients in redux. 

  63. Now that we have implemented ADD_INGREDIENT and REMOVE_INGREDIENT reducers, let's connect BurgerBuilder with store.
      We have already added Provider in the index.js and passed store into that, let's now receive it in BurgerBuilder with 
      the help of connect(), the function that returns hoc.

  64. Let's work on totalPrice and move it into the reducer from BurgerBuilder. Also, we will take a look at the disabled order button
      in the next commit .We can now delete addIngredientHanlder() and removeIngredientHanlder() in BurgerBuilder as we are handling them in 
      reducer.js.  

  65. We now work on enabling order button in BurgerBuilder. updatePurchaseState() method is the one which used to update
      purchasable property of state of BurgerBuilder till now. But now, we can remove purchasable property from state 
      and we can call updatePurchaseState() directly in BurgerBuilder's BuildControls component call in render method.
      Now if you see the state of BurgerBuilder, we have only 3 properties mentioned below - all related to UI of this 
      particular component only, so it makes sense to be in this state itself.

        state = {
            purchasing: false,
            loading: false,
            error: false 
        };

  66. We now think of checkout component. The BurgerBuilder used to pass queryparams for the reason explained in point number 38. 
      above to the checkout component. The checkout component then uses this queryParams to build the ingredients in its 
      local state. Now we don't need queryparams passing and receiving hassle anymore as we use redux now. Let's adjust the 
      code in both the components accordingly. 
      Let's also look at ContactData component. The Checkout component passes ingredients and totalPrice to the ContactData
      hence we can use redux there as well. 

* * * Tag v2.1 - completed - redux part for sync part (ingredients and totalPrice) in BurgerBuilder, Checkout and ContactData components. 
                             Need to move to async part next (fetching orders and ingredients from backend)